import test from 'ava';
import { expect } from 'chai';
import * as math from '../../src/math';

test('Math Library Object Definition', t => {
	expect(math.Angle.between).to.be.a('function');
	expect(math.Angle.betweenY).to.be.a('function');
	expect(math.Angle.betweenPoints).to.be.a('function');
	expect(math.Angle.betweenPointsY).to.be.a('function');
	expect(math.Angle.reverse).to.be.a('function');
	expect(math.Angle.normalize).to.be.a('function');
	expect(math.Angle.wrap).to.be.a('function');
	expect(math.Angle.wrapDeg).to.be.a('function');
	expect(math.Average).to.be.a('function');
	expect(math.Bernstein).to.be.a('function');
	expect(math.Between).to.be.a('function');
	expect(math.CatmullRom).to.be.a('function');
	expect(math.CeilTo).to.be.a('function');
	expect(math.Clamp).to.be.a('function');
	expect(math.Constants).to.be.a('Object');
	expect(math.DegToRad).to.be.a('function');
	expect(math.Difference).to.be.a('function');
	expect(math.Factorial).to.be.a('function');
	expect(math.FloatBetween).to.be.a('function');
	expect(math.FloorTo).to.be.a('function');
	expect(math.Fuzzy.equal).to.be.a('function');
	expect(math.Fuzzy.lessThan).to.be.a('function');
	expect(math.Fuzzy.greaterThan).to.be.a('function');
	expect(math.Fuzzy.ceil).to.be.a('function');
	expect(math.Fuzzy.floor).to.be.a('function');
	expect(math.GetPow2).to.be.a('function');
	expect(math.IsPow2).to.be.a('function');
	expect(math.Linear).to.be.a('function');
	expect(math.Math).to.be.a('function');
	expect(math.MaxAdd).to.be.a('function');
	expect(math.MinSub).to.be.a('function');
	expect(math.Percent).to.be.a('function');
	expect(math.RadToDeg).to.be.a('function');
	expect(math.RandomDataGenerator).to.be.a('function');
	expect(math.Rotate).to.be.a('function');
	expect(math.RotateAround).to.be.a('function');
	expect(math.RoundAwayFromZero).to.be.a('function');
	expect(math.RoundTo).to.be.a('function');
	expect(math.SinCosTableGenerator).to.be.a('function');
	expect(math.SmootherStep).to.be.a('function');
	expect(math.SmoothStep).to.be.a('function');
	expect(math.SnapTo.to).to.be.a('function');
	expect(math.SnapTo.floor).to.be.a('function');
	expect(math.SnapTo.ceil).to.be.a('function');
	expect(math.Wrap).to.be.a('function');
});

test('Math Distance Library Object Definition', t => {
	const { distance } = math;
	expect(distance.DistanceBetween).to.be.a('function');
	expect(distance.DistancePower).to.be.a('function');
	expect(distance.DistanceSquared).to.be.a('function');
});

test('Math Easing Library Object Definition', t => {
	const { easing } = math;
	expect(easing.Back.In).to.be.a('function');
	expect(easing.Back.Out).to.be.a('function');
	expect(easing.Back.InOut).to.be.a('function');
	expect(easing.Bounce.In).to.be.a('function');
	expect(easing.Bounce.Out).to.be.a('function');
	expect(easing.Bounce.InOut).to.be.a('function');
	expect(easing.Circular.In).to.be.a('function');
	expect(easing.Circular.Out).to.be.a('function');
	expect(easing.Circular.InOut).to.be.a('function');
	expect(easing.Cubic.In).to.be.a('function');
	expect(easing.Cubic.Out).to.be.a('function');
	expect(easing.Cubic.InOut).to.be.a('function');
	expect(easing.Elastic.In).to.be.a('function');
	expect(easing.Elastic.Out).to.be.a('function');
	expect(easing.Elastic.InOut).to.be.a('function');
	expect(easing.Expo.In).to.be.a('function');
	expect(easing.Expo.Out).to.be.a('function');
	expect(easing.Expo.InOut).to.be.a('function');
	expect(easing.Linear).to.be.a('function');
	expect(easing.Quadratic.In).to.be.a('function');
	expect(easing.Quadratic.Out).to.be.a('function');
	expect(easing.Quadratic.InOut).to.be.a('function');
	expect(easing.Quartic.In).to.be.a('function');
	expect(easing.Quartic.Out).to.be.a('function');
	expect(easing.Quartic.InOut).to.be.a('function');
	expect(easing.Quintic.In).to.be.a('function');
	expect(easing.Quintic.Out).to.be.a('function');
	expect(easing.Quintic.InOut).to.be.a('function');
	expect(easing.Sine.In).to.be.a('function');
	expect(easing.Sine.Out).to.be.a('function');
	expect(easing.Sine.InOut).to.be.a('function');
});

test('Math Interpolation Library Object Definition', t => {
	const { interpolation } = math;
	expect(interpolation.Bezier).to.be.a('function');
	expect(interpolation.CatmullRom).to.be.a('function');
	expect(interpolation.Linear).to.be.a('function');
});

test('Math Matrix Library Object Definition', t => {
	const { matrix } = math;
	const { mat23 } = matrix;
	const { mat33 } = matrix;
	const { mat34 } = matrix;
	const { mat43 } = matrix;
	const { mat44 } = matrix;

	expect(mat23.Add).to.be.a('function');
	expect(mat23.Build).to.be.a('function');
	expect(mat23.BuildIdentity).to.be.a('function');
	expect(mat23.Clone).to.be.a('function');
	expect(mat23.Copy).to.be.a('function');
	expect(mat23.Determinant).to.be.a('function');
	expect(mat23.Invert).to.be.a('function');
	expect(mat23.IsIdentity).to.be.a('function');
	expect(mat23.Multiply).to.be.a('function');
	expect(mat23.Rotate).to.be.a('function');
	expect(mat23.ScalarAdd).to.be.a('function');
	expect(mat23.ScalarMultiply).to.be.a('function');
	expect(mat23.ScalarSubtract).to.be.a('function');
	expect(mat23.Scale).to.be.a('function');
	expect(mat23.Set).to.be.a('function');
	expect(mat23.SetIdentity).to.be.a('function');
	expect(mat23.Subtract).to.be.a('function');
	expect(mat23.Transform).to.be.a('function');
	expect(mat23.Translate).to.be.a('function');

	expect(mat33.At).to.be.a('function');
	expect(mat33.Build).to.be.a('function');
	expect(mat33.BuildIdentity).to.be.a('function');
	expect(mat33.Copy).to.be.a('function');
	expect(mat33.Determinant).to.be.a('function');
	expect(mat33.Equal).to.be.a('function');
	expect(mat33.FromAxisRotation).to.be.a('function');
	expect(mat33.FromQuaternion).to.be.a('function');
	expect(mat33.Inverse).to.be.a('function');
	expect(mat33.InverseTranspose).to.be.a('function');
	expect(mat33.Mat33).to.be.a('function');
	expect(mat33.Multiply.Multiply).to.be.a('function');
	expect(mat33.Multiply.mat43).to.be.a('function');
	expect(mat33.Multiply.mat44).to.be.a('function');
	expect(mat33.Right).to.be.a('function');
	expect(mat33.ScalarAdd).to.be.a('function');
	expect(mat33.ScalarMultiply).to.be.a('function');
	expect(mat33.ScalarSub).to.be.a('function');
	expect(mat33.SetAt).to.be.a('function');
	expect(mat33.SetRight).to.be.a('function');
	expect(mat33.SetUp).to.be.a('function');
	expect(mat33.Transform).to.be.a('function');
	expect(mat33.TransformByVector).to.be.a('function');
	expect(mat33.Transpose).to.be.a('function');
	expect(mat33.Up).to.be.a('function');

	expect(mat43.At).to.be.a('function');
	expect(mat43.Build).to.be.a('function');
	expect(mat43.BuildIdentity).to.be.a('function');
	expect(mat43.BuildTranslation).to.be.a('function');
	expect(mat43.Copy).to.be.a('function');
	expect(mat43.Determinant).to.be.a('function');
	expect(mat43.FromAxisRotation).to.be.a('function');
	expect(mat43.FromM33V3).to.be.a('function');
	expect(mat43.FromQuaternionPos).to.be.a('function');
	expect(mat43.FromRT).to.be.a('function');
	expect(mat43.FromRTS).to.be.a('function');
	expect(mat43.Inverse).to.be.a('function');
	expect(mat43.InverseOrthonormal).to.be.a('function');
	expect(mat43.InverseTransposeProjection).to.be.a('function');
	expect(mat43.Multiply.Multiply).to.be.a('function');
	expect(mat43.Multiply.mat33).to.be.a('function');
	expect(mat43.Multiply.mat44).to.be.a('function');
	expect(mat43.MultiplyTranspose).to.be.a('function');
	expect(mat43.NegOffset).to.be.a('function');
	expect(mat43.Offset).to.be.a('function');
	expect(mat43.Orthonormalize).to.be.a('function');
	expect(mat43.Pos).to.be.a('function');
	expect(mat43.Right).to.be.a('function');
	expect(mat43.ScalarAdd).to.be.a('function');
	expect(mat43.ScalarMultiply).to.be.a('function');
	expect(mat43.ScalarSub).to.be.a('function');
	expect(mat43.Scale).to.be.a('function');
	expect(mat43.SetAt).to.be.a('function');
	expect(mat43.SetAxisRotation).to.be.a('function');
	expect(mat43.SetPos).to.be.a('function');
	expect(mat43.SetRight).to.be.a('function');
	expect(mat43.SetUp).to.be.a('function');
	expect(mat43.TransformPoint).to.be.a('function');
	expect(mat43.TransformVector).to.be.a('function');
	expect(mat43.Translate).to.be.a('function');
	expect(mat43.Transpose).to.be.a('function');
	expect(mat43.Up).to.be.a('function');

	expect(mat34.BuildIdentity).to.be.a('function');
	expect(mat34.Pos).to.be.a('function');
	expect(mat34.Scale).to.be.a('function');

	expect(mat44.At).to.be.a('function');
	expect(mat44.Build).to.be.a('function');
	expect(mat44.BuildIdentity).to.be.a('function');
	expect(mat44.Copy).to.be.a('function');
	expect(mat44.Inverse).to.be.a('function');
	expect(mat44.Multiply).to.be.a('function');
	expect(mat44.Pos).to.be.a('function');
	expect(mat44.Right).to.be.a('function');
	expect(mat44.ScalarAdd).to.be.a('function');
	expect(mat44.ScalarMultiply).to.be.a('function');
	expect(mat44.ScalarSub).to.be.a('function');
	expect(mat44.Scale).to.be.a('function');
	expect(mat44.SetAt).to.be.a('function');
	expect(mat44.SetPos).to.be.a('function');
	expect(mat44.SetRight).to.be.a('function');
	expect(mat44.SetUp).to.be.a('function');
	expect(mat44.TransformVector).to.be.a('function');
	expect(mat44.Translate).to.be.a('function');
	expect(mat44.Transpose).to.be.a('function');
	expect(mat44.Up).to.be.a('function');
});

test('Math Quanternion Library Object Definition', t => {
	const { quaternion } = math;
	expect(quaternion.Build).to.be.a('function');
	expect(quaternion.Conjugate).to.be.a('function');
	expect(quaternion.Copy).to.be.a('function');
	expect(quaternion.Dot).to.be.a('function');
	expect(quaternion.Equal).to.be.a('function');
	expect(quaternion.FromAxisRotation).to.be.a('function');
	expect(quaternion.FromM43).to.be.a('function');
	expect(quaternion.IsSimilar).to.be.a('function');
	expect(quaternion.Length).to.be.a('function');
	expect(quaternion.Lerp).to.be.a('function');
	expect(quaternion.Multiply).to.be.a('function');
	expect(quaternion.MultiplyTranslate).to.be.a('function');
	expect(quaternion.Normalize).to.be.a('function');
	expect(quaternion.PosBuild).to.be.a('function');
	expect(quaternion.PosMultiply).to.be.a('function');
	expect(quaternion.PosTransformPoint).to.be.a('function');
	expect(quaternion.PosTransformVector).to.be.a('function');
	expect(quaternion.Slerp).to.be.a('function');
	expect(quaternion.ToAxisRotation).to.be.a('function');
	expect(quaternion.TransformVector).to.be.a('function');
});

test('Math Transform Library Object Definition', t => {
	const { transform } = math;
	const { twoDimensional } = transform;
	const { basic } = twoDimensional;
	const { components } = twoDimensional;
	const { minimal } = twoDimensional;
	const { standard } = twoDimensional;

	expect(twoDimensional.SetTransformToContext).to.be.a('function');
	expect(twoDimensional.SetTransformToCSS).to.be.a('function');
	expect(basic.BaseTransform).to.be.a('function');
	expect(basic.Transform).to.be.a('function');
	expect(components.BaseTransformComponent).to.be.a('function');
	expect(components.Pivot).to.be.a('function');
	expect(components.Position).to.be.a('function');
	expect(components.Rotation).to.be.a('function');
	expect(components.RotationAnchor).to.be.a('function');
	expect(components.Scale).to.be.a('function');
	expect(minimal.BaseTransform).to.be.a('function');
	expect(minimal.Transform).to.be.a('function');
	expect(standard.BaseTransform).to.be.a('function');
	expect(standard.Transform).to.be.a('function');
});

test('Math Vector Library Object Definition', t => {
	const { vector } = math;
	const { common, vec2, vec3, vec4 } = vector;

	expect(common.Rotate).to.be.a('function');
	expect(common.RotateAround).to.be.a('function');

	expect(vec2.Abs).to.be.a('function');
	expect(vec2.Add).to.be.a('function');
	expect(vec2.Add3).to.be.a('function');
	expect(vec2.Add4).to.be.a('function');
	expect(vec2.Angle).to.be.a('function');
	expect(vec2.Build).to.be.a('function');
	expect(vec2.BuildOne).to.be.a('function');
	expect(vec2.BuildXAxis).to.be.a('function');
	expect(vec2.BuildYAxis).to.be.a('function');
	expect(vec2.BuildZero).to.be.a('function');
	expect(vec2.Ceil).to.be.a('function');
	expect(vec2.Copy).to.be.a('function');
	expect(vec2.Distance).to.be.a('function');
	expect(vec2.DistanceSq).to.be.a('function');
	expect(vec2.Dot).to.be.a('function');
	expect(vec2.Equal).to.be.a('function');
	expect(vec2.Floor).to.be.a('function');
	expect(vec2.Length).to.be.a('function');
	expect(vec2.LengthSq).to.be.a('function');
	expect(vec2.Lerp).to.be.a('function');
	expect(vec2.Mask.equal).to.be.a('function');
	expect(vec2.Mask.less).to.be.a('function');
	expect(vec2.Mask.greater).to.be.a('function');
	expect(vec2.Mask.greaterEq).to.be.a('function');
	expect(vec2.Mask.not).to.be.a('function');
	expect(vec2.Max).to.be.a('function');
	expect(vec2.Min).to.be.a('function');
	expect(vec2.Multiply).to.be.a('function');
	expect(vec2.MultiplyAdd).to.be.a('function');
	expect(vec2.Neg).to.be.a('function');
	expect(vec2.Normalize).to.be.a('function');
	expect(vec2.ObservableVec2).to.be.a('function');
	expect(vec2.PerpDot).to.be.a('function');
	expect(vec2.Project).to.be.a('function');
	expect(vec2.Reciprocal).to.be.a('function');
	expect(vec2.ScalarAdd).to.be.a('function');
	expect(vec2.ScalarBuild).to.be.a('function');
	expect(vec2.ScalarMask.equal).to.be.a('function');
	expect(vec2.ScalarMask.less).to.be.a('function');
	expect(vec2.ScalarMask.greater).to.be.a('function');
	expect(vec2.ScalarMask.greaterEq).to.be.a('function');
	expect(vec2.ScalarMin).to.be.a('function');
	expect(vec2.ScalarMultiply).to.be.a('function');
	expect(vec2.ScalarMultiplyAdd).to.be.a('function');
	expect(vec2.ScalarSub).to.be.a('function');
	expect(vec2.Select).to.be.a('function');
	expect(vec2.Set).to.be.a('function');
	expect(vec2.Sub).to.be.a('function');
	expect(vec2.Vec2).to.be.a('function');

	expect(vec3.Abs).to.be.a('function');
	expect(vec3.Add).to.be.a('function');
	expect(vec3.Add3).to.be.a('function');
	expect(vec3.Add4).to.be.a('function');
	expect(vec3.Angle).to.be.a('function');
	expect(vec3.Build).to.be.a('function');
	expect(vec3.BuildOne).to.be.a('function');
	expect(vec3.BuildXAxis).to.be.a('function');
	expect(vec3.BuildYAxis).to.be.a('function');
	expect(vec3.BuildZero).to.be.a('function');
	expect(vec3.Copy).to.be.a('function');
	expect(vec3.Cross).to.be.a('function');
	expect(vec3.Distance).to.be.a('function');
	expect(vec3.DistanceSq).to.be.a('function');
	expect(vec3.Dot).to.be.a('function');
	expect(vec3.Equal).to.be.a('function');
	expect(vec3.Length).to.be.a('function');
	expect(vec3.LengthSq).to.be.a('function');
	expect(vec3.Lerp).to.be.a('function');
	expect(vec3.Mask.equal).to.be.a('function');
	expect(vec3.Mask.less).to.be.a('function');
	expect(vec3.Mask.greater).to.be.a('function');
	expect(vec3.Mask.greaterEq).to.be.a('function');
	expect(vec3.Mask.not).to.be.a('function');
	expect(vec3.Max).to.be.a('function');
	expect(vec3.Min).to.be.a('function');
	expect(vec3.Multiply).to.be.a('function');
	expect(vec3.MultiplyAdd).to.be.a('function');
	expect(vec3.Neg).to.be.a('function');
	expect(vec3.Normalize).to.be.a('function');
	expect(vec3.Project).to.be.a('function');
	expect(vec3.Reciprocal).to.be.a('function');
	expect(vec3.ScalarAdd).to.be.a('function');
	expect(vec3.ScalarBuild).to.be.a('function');
	expect(vec3.ScalarMask.equal).to.be.a('function');
	expect(vec3.ScalarMask.less).to.be.a('function');
	expect(vec3.ScalarMask.greater).to.be.a('function');
	expect(vec3.ScalarMask.greaterEq).to.be.a('function');
	expect(vec3.ScalarMin).to.be.a('function');
	expect(vec3.ScalarMultiply).to.be.a('function');
	expect(vec3.ScalarMultiplyAdd).to.be.a('function');
	expect(vec3.ScalarSub).to.be.a('function');
	expect(vec3.Select).to.be.a('function');
	expect(vec3.Set).to.be.a('function');
	expect(vec3.Sub).to.be.a('function');
	expect(vec3.Vec3).to.be.a('function');

	expect(vec4.Abs).to.be.a('function');
	expect(vec4.Add).to.be.a('function');
	expect(vec4.Add3).to.be.a('function');
	expect(vec4.Add4).to.be.a('function');
	expect(vec4.Build).to.be.a('function');
	expect(vec4.BuildOne).to.be.a('function');
	expect(vec4.BuildZero).to.be.a('function');
	expect(vec4.Copy).to.be.a('function');
	expect(vec4.Dot).to.be.a('function');
	expect(vec4.Equal).to.be.a('function');
	expect(vec4.Length).to.be.a('function');
	expect(vec4.LengthSq).to.be.a('function');
	expect(vec4.Many).to.be.a('function');
	expect(vec4.Mask.equal).to.be.a('function');
	expect(vec4.Mask.less).to.be.a('function');
	expect(vec4.Mask.greater).to.be.a('function');
	expect(vec4.Mask.greaterEq).to.be.a('function');
	expect(vec4.Mask.not).to.be.a('function');
	expect(vec4.Max).to.be.a('function');
	expect(vec4.Min).to.be.a('function');
	expect(vec4.Multiply).to.be.a('function');
	expect(vec4.MultiplyAdd).to.be.a('function');
	expect(vec4.Neg).to.be.a('function');
	expect(vec4.Reciprocal).to.be.a('function');
	expect(vec4.ScalarAdd).to.be.a('function');
	expect(vec4.ScalarBuild).to.be.a('function');
	expect(vec4.ScalarMask.equal).to.be.a('function');
	expect(vec4.ScalarMask.less).to.be.a('function');
	expect(vec4.ScalarMask.greater).to.be.a('function');
	expect(vec4.ScalarMask.greaterEq).to.be.a('function');
	expect(vec4.ScalarMin).to.be.a('function');
	expect(vec4.ScalarMultiply).to.be.a('function');
	expect(vec4.ScalarMultiplyAdd).to.be.a('function');
	expect(vec4.ScalarSub).to.be.a('function');
	expect(vec4.Select).to.be.a('function');
	expect(vec4.Set).to.be.a('function');
	expect(vec4.Sub).to.be.a('function');

});